class Solution {
    public int maxCapacity(int[] costs, int[] capacity, int budget) {
        int n = costs.length;
        int maxCost = 0;
        for (int cost : costs) {
            maxCost = Math.max(maxCost, cost);
        }

        // max1[c] is the highest capacity for cost c
        // max2[c] is the second highest capacity for cost c
        int[] max1 = new int[maxCost + 1];
        int[] max2 = new int[maxCost + 1];
        int maxCap = 0;

        for (int i = 0; i < n; i++) {
            int c = costs[i];
            int cap = capacity[i];

            // Case 1: Only one machine
            if (c < budget) {
                maxCap = Math.max(maxCap, cap);
            }

            // Update top 2 capacities for this specific cost
            if (cap > max1[c]) {
                max2[c] = max1[c];
                max1[c] = cap;
            } else if (cap > max2[c]) {
                max2[c] = cap;
            }
        }

        // prefBest[c] is the highest capacity for any cost <= c
        int[] prefBest = new int[maxCost + 1];
        for (int c = 1; c <= maxCost; c++) {
            prefBest[c] = Math.max(prefBest[c - 1], max1[c]);
        }

        // Case 2: Two distinct machines
        for (int c = 1; c <= maxCost; c++) {
            if (max1[c] == 0) continue;

            // Option A: Two machines with the same cost c
            if (2 * c < budget && max2[c] > 0) {
                maxCap = Math.max(maxCap, max1[c] + max2[c]);
            }

            // Option B: One machine with cost c and one machine with cost k < c
            // We need k < budget - c AND k < c
            int limit = Math.min(c - 1, budget - c - 1);
            if (limit > 0) {
                if (prefBest[limit] > 0) {
                    maxCap = Math.max(maxCap, max1[c] + prefBest[limit]);
                }
            }
        }

        return maxCap;
    }
}
